__author__ = "MarkusDoepfert"__credits__ = ""__license__ = ""__maintainer__ = "MarkusDoepfert"__email__ = "markus.doepfert@tum.de"# This file is in charge of the trading strategy for the markets# Importsimport osimport pandas as pdimport polars as plimport numpy as npimport timeimport loggingimport tracebackfrom datetime import datetimefrom hamlet.executor.utilities.forecasts.forecaster import Forecasterfrom hamlet.executor.utilities.controller.controller import Controllerfrom hamlet.executor.utilities.database.database import Databasefrom hamlet.executor.utilities.trading.strategies import *from hamlet import constants as cfrom pprint import pprintclass Trading:    def __init__(self, strategy: str, **kwargs):        self.kwargs = kwargs        # Mapping of controller types to classes        strategies = {            'linear': Linear,            'zi': Zi,        }        # Lookup the class based on the controller_type        self.strategy = strategies.get(strategy.lower())        if self.strategy is None:            raise ValueError(f'Trading strategy {strategy} not available. \n'                             f'The available methods are: {strategies.keys()}. \n'                             f'If you think this is an error, you might have forgotten to import the method to the '                             f'class or named it incorrectly.')    def create_instance(self):        return self.strategy(**self.kwargs)## Seb's old functiondef market_agent(self, db_obj, clear_positions=False):    """Calculate and post/update market positions to the double sided market.    :param db_obj: Database instance, pass the database connection instance to this method    :return:    """    # generate list of potential bids from MPC results    # all grid flows are potential bids    df_potential_bids = pd.DataFrame(        self.mpc_table[(self.ts_delivery_current <= self.mpc_table.index)                       & (self.mpc_table.index <= self.ts_delivery_current                          + 15 * 60 * self.config_dict["ma_horizon"])]        [f"power_{self.config_dict['id_meter_grid']}"]) / 4    df_potential_bids.rename(columns={f"power_{self.config_dict['id_meter_grid']}": "net_bids"}, inplace=True)    df_potential_bids["net_bids"] = df_potential_bids["net_bids"] - self.matched_bids_by_timestep["net_bids"]    dict_pot_bids = df_potential_bids.to_dict()    index_pot_bids = sorted(list(dict_pot_bids["net_bids"]))    dict_positions = {        db_obj.db_param.ID_USER: [],        db_obj.db_param.QTY_ENERGY: [],        db_obj.db_param.PRICE_ENERGY: [],        db_obj.db_param.QUALITY_ENERGY: [],        db_obj.db_param.PREMIUM_PREFERENCE_QUALITY: [],        db_obj.db_param.TYPE_POSITION: [],        db_obj.db_param.NUMBER_POSITION: [],        db_obj.db_param.STATUS_POSITION: [],        db_obj.db_param.T_SUBMISSION: [],        db_obj.db_param.TS_DELIVERY: []}    euro_kwh_to_sigma_wh = db_obj.db_param.EURO_TO_SIGMA / 1000    delta = 0    gradient = (self.config_dict["max_bid"] - self.config_dict["min_offer"]) / (            self.config_dict["ma_horizon"] - 1)    for t_s in index_pot_bids:        """Market logic to be inserted at this point. In order to be posted, bids must be assigned prices"""        if t_s > self.ts_delivery_current:            # determine energy to be traded            energy_position = round(dict_pot_bids["net_bids"][t_s])            if abs(energy_position) >= 10:                post_position = True            else:                post_position = False            has_renewable = False            has_non_ren = False            for plant in self._get_list_plants("pv") + self._get_list_plants("fixedgen"):                if self.plant_dict[plant]["quality"] in ["green_local"]:                    has_renewable = True                if self.plant_dict[plant]["quality"] in ["local"]:                    has_non_ren = True            if energy_position < 0:                quality = self.config_dict["ma_preference_quality"]                premium = self.config_dict["ma_premium_preference_quality"]            elif energy_position > 0 and has_non_ren:                quality = "local"                premium = 0            elif energy_position > 0 and has_renewable:                quality = "green_local"                premium = 0            else:                quality = "na"                premium = 0            if self.config_dict["ma_strategy"] == "zi":                # determine energy price,                price = self.config_dict["min_offer"] \                        + random() * (self.config_dict["max_bid"] - self.config_dict["min_offer"])                price = round(price, 4)                price *= euro_kwh_to_sigma_wh            else:                if energy_position < 0:                    price = round(self.config_dict["max_bid"] - delta, 6)                    price *= euro_kwh_to_sigma_wh                else:                    price = round(self.config_dict["min_offer"] + delta, 6)                    price *= euro_kwh_to_sigma_wh            if post_position:                dict_positions[db_obj.db_param.ID_USER].append(self.config_dict['id_market_agent'])                dict_positions[db_obj.db_param.QTY_ENERGY].append(abs(energy_position))                dict_positions[db_obj.db_param.TYPE_POSITION].append("offer" if energy_position > 0 else "bid")                dict_positions[db_obj.db_param.NUMBER_POSITION].append(0)                dict_positions[db_obj.db_param.STATUS_POSITION].append(0)                dict_positions[db_obj.db_param.PRICE_ENERGY].append(price)                dict_positions[db_obj.db_param.QUALITY_ENERGY].append(quality)                dict_positions[db_obj.db_param.PREMIUM_PREFERENCE_QUALITY].append(premium)                dict_positions[db_obj.db_param.T_SUBMISSION].append(self.t_now)                dict_positions[db_obj.db_param.TS_DELIVERY].append(t_s)            delta += gradient    if clear_positions:        db_obj.clear_positions(id_user=self.config_dict['id_market_agent'])    if len(dict_positions[db_obj.db_param.ID_USER]) > 0:        df_bids = pd.DataFrame(dict_positions)        db_obj.post_positions(df_bids,                              t_override=self.t_now)